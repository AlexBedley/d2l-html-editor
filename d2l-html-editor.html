<link rel="import" href="../polymer/polymer.html">
<script type="text/javascript" src="../tinymce/tinymce.js"></script>
<script type="text/javascript" src="https://s.brightspace.com/lib/ifrau/0.13.1/ifrau/client.js"></script>

<!--<link rel="import" href="./vui-input-styles.html">-->

<!--
An element providing a solution to no problem in particular.

Example:

		<d2l-html-editor></d2l-html-editor>

@demo
-->
<dom-module id="d2l-html-editor">

	<template>
		<style>
			:host {
				display: block;
				position: relative;
			}

			.toolbar {
				display: none;
				position: absolute;
				top: -3.2rem;
				z-index: 1001;
				display: inline-block;
				right: 0rem;
			}
			/*
			:host[dir="ltr"] .toolbar {
				right: -1rem;
			}
			*/

			:host-context([dir='rtl']) .toolbar {
				left: 0rem;
				right: inherit;
			}

			.toolbar-visible {
				display: inline-block;
			}

			:host ::content div > p:first-child {
				margin-top: 0
			}

			:host ::content div > p:last-child {
				margin-bottom: 0;
			}

			:host ::content img {
				max-width: 100%;
			}

		</style>

		<div id$="[[toolbarId]]" class="toolbar"></div>
		<content></content>

	</template>

</dom-module>

<script>
	Polymer({

		is: 'd2l-html-editor',

		listeners: {
			'focus': 'toolbarVisible',
			'blur': 'toolbarHidden'
		},
		/**
		 * @see tinymce config
		 */
		properties: {
			autoFocus: {
				type: Number,
				value: 0
			},
			minRows: {
				type: Number,
				value: 1
			},
			maxRows: {
				type: Number,
				value: 3
			},
			totalPadding: {
				type: Number,
				value: 0.9
			},
			lineHeight: {
				type: Number,
				value: 1.2
			},
			minHeight: {
				type: String,
				computed: 'computeHeight(totalPadding, minRows, lineHeight)'
			},
			maxHeight: {
				type: String,
				computed: 'computeHeight(totalPadding, maxRows, lineHeight)'
			},
			editorId: String,
			toolbarId: {
				type: String,
				computed: 'computeToolbarId(editorId)'
			},
			content: String,
			baseUrl: {
				type: String,
				value: null
			},
			documentBaseUrl: {
				type: String,
				value: null
			}
		},

		/**
		 * Textarea where tinymce is instantiate
		 * @return {HTMLElement}
		 */
		element: null,

		// Element Lifecycle

		ready: function() {
			// `ready` is called after all elements have been configured, but
			// propagates bottom-up. This element's children are ready, but parents
			// are not.
			//
			// This is the point where you should make modifications to the DOM (when
			// necessary), or kick off any processes the element wants to perform.
		},

		attached: function() {
			// `attached` fires once the element and its parents have been inserted
			// into a document.
			//
			// This is a good place to perform any work related to your element's
			// visual state or active behavior (measuring sizes, beginning animations,
			// loading resources, etc).

			this.initialize();
			this.fire('d2l-html-editor-attached');
		},

		detached: function() {
			// The analog to `attached`, `detached` fires when the element has been
			// removed from a document.
			//
			// Use this to clean up anything you did in `attached`.
			this.cleanup();
		},

		initialize: function(client) {

			if (this.client) {
				return;
			}

			var client2 = window.ifrauclient();
			client2.connect().then(function() {
				this._init(client2);
				this._configureTinyMce(client2);
			}.bind(this));

		},

		// We cannot cleanup in detached because React seems to cause the web component
		// to detach/attach during move operations
		cleanup: function() {
			tinymce.EditorManager.execCommand('mceRemoveEditor', true, this.editorId); // eslint-disable-line no-undef
			this.client = null;
		},

		focus: function() {
			tinymce.EditorManager.get(this.editorId).focus(); // eslint-disable-line no-undef
		},

		_init: function(client) {
			if (null !== this.baseUrl) {
				tinyMCE.baseURL = this.baseUrl; // eslint-disable-line
			}

			this.client = client;
			this.element = Polymer.dom(this).querySelector('#' + this.editorId);
			this.element.style.overflowY = 'auto';
			this.element.style.minHeight = this.minHeight;
			this.element.style.maxHeight = this.maxHeight;
		},

		/**
		 * Init tinyMCE
		 * @private
		 */
		_initTinyMCE: function(plugins, buttons) {
			var that = this;
			var config = {
				selector: '#' + this.editorId,
				plugins: plugins + ' image',
				toolbar: buttons + ' image',
				auto_focus: this.autoFocus ? this.editorId : null,
				menubar: false,
				fixed_toolbar_container: '#' + this.toolbarId,
				inline: true,
				document_base_url: this.documentBaseUrl + '/',
				convert_urls: false,
				relative_urls: false,
				setup: function(editor) {
					editor.on('change', function() {
						that.fire('change', {content: editor.getContent()});
					});
					editor.on('focusin', function(e) {
						that.fire('focus', e);
					});
					editor.on('focusout', function(e) {
						that.fire('blur', e);
					});

					editor.on('keyup', function() {
						that.element.value = editor.getContent();
					});
				}
			};

			if (this.content_css) {
				config.content_css = this.content_css;
			}

			tinymce.init(config); // eslint-disable-line no-undef

			// need to reset auto focus property to prevent unwanted focus during re-ordering of the options
			this.autoFocus = 0;
		},

		toolbarVisible: function() {
			this.toggleClass('toolbar-visible', true, this.$.toolbar);
		},

		toolbarHidden: function() {
			this.toggleClass('toolbar-visible', false, this.$.toolbar);
		},

		computeToolbarId: function(editorId) {
			return editorId + '-toolbar';
		},

		computeHeight: function(totalPadding, rows, lineHeight) {
			return totalPadding + (lineHeight * rows) + 'rem';
		},

		_buttonDefinitions: function() {
			var buttons = [];

			buttons.push({
				id: 'bold'
			});

			buttons.push({
				id: 'italic'
			});

			buttons.push({
				id: 'underline'
			});

			buttons.push({
				id: 'd2l_image',
				label: 'Add Image',
				icon: 'd2l_image',
				serviceId: 'fra-html-editor-image',
				cmd: function(editorId, service) {
					var editor = tinymce.get(editorId);   // eslint-disable-line no-undef
					var bookmark = editor.selection.getBookmark();
					service.click().then(function(response) {
						editor.focus();
						editor.selection.moveToBookmark(bookmark);
						editor.execCommand('mceInsertContent', false, response);
						/// editor.selection.setContent(response);
					});
				}
			});

			return buttons;
		},

		_configureButtons: function(client, editorId) {
			var buttonDefinitions = this._buttonDefinitions();
			var buttons = [];
			buttonDefinitions.forEach(function(button) {
				if (button.serviceId) {
					buttons.push(this._addPlugin(client, editorId, button));
				} else {
					buttons.push(button);
				}
			}, this);
			return buttons;
		},

		_addPlugin: function(client, editorId, button) {
			return client.getService(button.serviceId, '0.1').then(function(service) {
				return service.enabled();
			}).then(function() {
				var d2lEditor = this;
				var pluginId = d2lEditor._pluginId(editorId, button.id);
				tinymce.PluginManager.add(pluginId, function(editor) {   // eslint-disable-line no-undef
					editor.addButton(pluginId, {
						tooltip: button.label,
						icon: button.icon,
						onclick: function() {
							d2lEditor._callService(client, button.serviceId, editorId, button.cmd);
						}
					});
				});
				return {
					id: pluginId,
					isPlugin: true
				};

			}.bind(this))
			.catch(function() {
				return {};
			});
		},

		_configureTinyMce: function(client) {
			var buttons = this._configureButtons(client, this.editorId);
			Promise.all(buttons).then(function(resolvedButtons) {   // eslint-disable-line no-undef
				var resolvedToolbar = resolvedButtons.reduce(function(toolbar, item) {
					if (item.isPlugin && item.id) {
						toolbar.plugins.push(item.id);
						toolbar.buttons.push(item.id);
					} else if (item.id) {
						toolbar.buttons.push(item.id);
					}
					return toolbar;
				}, {
					plugins: [],
					buttons: []
				});
				this._initTinyMCE(resolvedToolbar.plugins.join(' '), resolvedToolbar.buttons.join(' '));
			}.bind(this));
		},

		_pluginId: function(editorId, pluginId) {
			var id = pluginId + '_' + editorId;
			return id.replace(new RegExp('-', 'g'), '_');
		},

		_callService: function(client, serviceId, editorId, fn) {
			client.getService(serviceId, '0.1').then(function(service) {
				fn.call(null, editorId, service);
			});
		}

	});

</script>
